Habr β How to become an author My feed All streams Development Administrating Design Management Marketing PopSci Search Write a publication Settings Login Pull to refresh ntz Mar 9 2011 at 18:47 Нечёткий поиск в тексте и словаре Reading time 13 min Views 268K Algorithms * Введение Алгоритмы нечеткого поиска (также известного как поиск по сходству или fuzzy string search ) являются основой систем проверки орфографии и полноценных поисковых систем вроде Google или Yandex. Например, такие алгоритмы используются для функций наподобие «Возможно вы имели в виду …» в тех же поисковых системах. В этой обзорной статье я рассмотрю следующие понятия, методы и алгоритмы: Расстояние Левенштейна Расстояние Дамерау-Левенштейна Алгоритм Bitap с модификациями от Wu и Manber Алгоритм расширения выборки Метод N-грамм Хеширование по сигнатуре BK-деревья А также проведу сравнительное тестирование качества и производительности алгоритмов. Итак... Нечеткий поиск является крайне полезной функцией любой поисковой системы. Вместе с тем, его эффективная реализация намного сложнее, чем реализация простого поиска по точному совпадению. Задачу нечеткого поиска можно сформулировать так: «По заданному слову найти в тексте или словаре размера n все слова, совпадающие с этим словом (или начинающиеся с этого слова) с учетом k возможных различий». Например, при запросе «Машина» с учетом двух возможных ошибок, найти слова «Машинка», «Махина», «Малина», «Калина» и так далее. Алгоритмы нечеткого поиска характеризуются метрикой — функцией расстояния между двумя словами, позволяющей оценить степень их сходства в данном контексте. Строгое математическое определение метрики включает в себя необходимость соответствия условию неравенства треугольника (X — множество слов, p — метрика): Между тем, в большинстве случаев под метрикой подразумевается более общее понятие, не требующее выполнения такого условия, это понятие можно также назвать расстоянием . В числе наиболее известных метрик — расстояния Хемминга , Левенштейна и Дамерау-Левенштейна . При этом расстояние Хемминга является метрикой только на множестве слов одинаковой длины, что сильно ограничивает область его применения. Впрочем, на практике расстояние Хемминга оказывается практически бесполезным, уступая более естественным с точки зрения человека метрикам, о которых и пойдет речь ниже. Расстояние Левенштейна Наиболее часто применяемой метрикой является расстояние Левенштейна, или расстояние редактирования, алгоритмы вычисления которого можно найти на каждом шагу. Тем не менее, стоит сделать несколько замечаний относительно наиболее популярного алгоритма расчета — метода Вагнера-Фишера . Исходный вариант этого алгоритма имеет временную сложность O(mn) и потребляет O(mn) памяти, где m и n — длины сравниваемых строк. Весь процесс можно представить следующей матрицей: Если посмотреть на процесс работы алгоритма, несложно заметить, что на каждом шаге используются только две последние строки матрицы, следовательно, потребление памяти можно уменьшить до O(min(m, n)) . Но это еще не всё — можно дальше оптимизировать алгоритм, если стоит задача нахождения не более k различий. В этом случае нужно вычислять в матрице лишь диагональную полосу шириной 2k+1 (отсечение Укконена), что сводит временную сложность к O(k min(m, n)) . Префиксное расстояние Также бывает необходимо вычислять расстояние между префиксом-образцом и строкой — т. е. найти расстояние между заданным префиксом и ближайшим префиксом строки. В этом случае необходимо взять наименьшее из расстояний от префикса-образца до всех префиксов строки. Очевидно, что префиксное расстояние не может считаться метрикой в строгом математическом смысле, что ограничивает его применение. Зачастую при нечетком поиске важно не столько само значение расстояния, сколько факт того, превышает оно или нет определенную величину. Расстояние Дамерау-Левенштейна Эта вариация вносит в определение расстояния Левенштейна еще одно правило — транспозиция (перестановка) двух соседних букв также учитывается как одна операция, наряду со вставками, удалениями и заменами. Еще пару лет назад Фредерик Дамерау мог бы гарантировать, что большинство ошибок при наборе текста — как раз и есть транспозиции. Поэтому именно данная метрика дает наилучшие результаты на практике. Чтобы вычислять такое расстояние, достаточно немного модифицировать алгоритм нахождения обычного расстояния Левенштейна следующим образом: хранить не две, а три последних строки матрицы, а также добавить соответствующее дополнительное условие — в случае обнаружения транспозиции при расчете расстояния также учитывать и её стоимость. Кроме рассмотренных выше, существует еще множество других, иногда применяющихся на практике расстояний, таких как метрика Джаро-Винклера , многие из которых доступны в библиотеках SimMetrics и SecondString . Алгоритмы нечеткого поиска без индексации (Онлайн) Эти алгоритмы предназначены для поиска по заранее неизвестному тексту, и могут быть использованы, например, в текстовых редакторах, программах для просмотра документов или в веб-браузерах для поиска по странице. Они не требуют предварительной обработки текста и могут работать с непрерывным потоком данных. Линейный поиск Простое последовательное применение заданной метрики (например, метрики Левенштейна) к словам из входного текста. При использовании метрики с ограничением, этот метод позволяет добиться оптимальной скорости работы. Но, при этом, чем больше k , тем сильнее возрастает время работы. Асимптотическая оценка времени — O(kn) . Bitap (также известный как Shift-Or или Baeza-Yates-Gonnet, и его модификация от Wu-Manber) Алгоритм Bitap и различные его модификации наиболее часто используются для нечеткого поиска без индексации. Его вариация используется, например, в unix-утилите agrep , выполняющей функции аналогично стандартному grep , но с поддержкой ошибок в поисковом запросе и даже предоставляя ограниченные возможности для применения регулярных выражений. Впервые идею этого алгоритма предложили граждане Ricardo Baeza-Yates и Gaston Gonnet , опубликовав соответствующую статью в 1992 году. Оригинальная версия алгоритма имеет дело только с заменами символов, и, фактически, вычисляет расстояние Хемминга . Но немного позже Sun Wu и Udi Manber предложили модификацию этого алгоритма для вычисления расстояния Левенштейна , т.е. привнесли поддержку вставок и удалений, и разработали на его основе первую версию утилиты agrep. Операция Bitshift &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Вставки Удаления Замены Результирующее значение Где k — количество ошибок, j — индекс символа, s x — маска символа (в маске единичные биты располагаются на позициях, соответствующих позициям данного символа в запросе). Совпадение или несовпадение запросу определяется самым последним битом результирующего вектора R. Высокая скорость работы этого алгоритма обеспечивается за счет битового параллелизма вычислений — за одну операцию возможно провести вычисления над 32 и более битами одновременно. При этом тривиальная реализация поддерживает поиск слов длиной не более 32. Это ограничение обуславливается шириной стандартного типа int (на 32-битных архитектурах). Можно использовать и типы больших размерностей, но это может в некоторой степени замедлить работу алгоритма. Не смотря на то, что асимптотическое время работы этого алгоритма O(kn) совпадает с таковым у линейного метода, он значительно быстрее при длинных запросах и количестве ошибок k более 2. Тестирование Тестирование осуществлялось на тексте 3.2 млн слов, средняя длина слова — 10. Точный поиск Время поиска: 3562 мс Поиск с использованием метрики Левенштейна Время поиска при k=2 : 5728 мс Время поиска при k=5 : 8385 мс Поиск с использованием алгоритма Bitap с модификациями Wu-Manber Время поиска при k=2 : 5499 мс Время поиска при k=5 : 5928 мс Очевидно, что простой перебор с использованием метрики, в отличие от алгоритма Bitap, сильно зависит от количества ошибок k . Тем не менее, если речь заходит о поиске в неизменных текстах большого объема, то время поиска можно значительно сократить, произведя предварительную обработку такого текста, также называемую индексацией . Алгоритмы нечеткого поиска с индексацией (Оффлайн) Особенностью всех алгоритмов нечеткого поиска с индексацией является то, что индекс строится по словарю, составленному по исходному тексту или списку записей в какой-либо базе данных. Эти алгоритмы используют различные подходы к решению проблемы — одни из них используют сведение к точному поиску, другие используют свойства метрики для построения различных пространственных структур и так далее. Прежде всего, на первом шаге по исходному тексту строится словарь, содержащий слова и их позиции в тексте. Также, можно подсчитывать частоты слов и словосочетаний для улучшения качества результатов поиска. Предполагается, что индекс, как и словарь, целиком загружен в память. Тактико-технические характеристики словаря: Исходный текст — 8.2 гигабайта материалов библиотеки Мошкова ( lib.ru ), 680 млн слов; Размер словаря — 65 мегабайт; Количество слов — 3.2 млн; Средняя длина слова — 9.5 символов; Средняя квадратичная длина слова (может быть полезна при оценке некоторых алгоритмов) — 10.0 символов; Алфавит — заглавные буквы А-Я, без Ё (для упрощения некоторых операций). Слова, содержащие символы не из алфавита, не включены в словарь. Зависимость размера словаря от объема текста не является строго линейной — до некоторого объема формируется базовый каркас слов, составляющий от 15% на 500 тысячах слов до 5% на 5 миллионах, и затем зависимость приближается к линейной, медленно убывая и доходя до 0.5% на 680 млн слов. Последующее сохранение роста обеспечивается в большинстве своем за счет редких слов. Алгоритм расширения выборки Этот алгоритм часто применяется в системах проверки орфографии (т.е. в spell-checker'ах), там, где размер словаря невелик, либо же где скорость работы не является основным критерием. Он основан на сведении задачи о нечетком поиске к задаче о точном поиске. Из исходного запроса строится множество «ошибочных» слов, для каждого из которых затем производится точный поиск в словаре. Время его работы сильно зависит от числа k ошибок и от размера алфавита A, и в случае использования бинарного поиска по словарю составляет: Например, при k = 1 и слова длины 7 (например, «Крокодил») в русском алфавите множество ошибочных слов будет размером около 450, то есть будет необходимо сделать 450 запросов к словарю, что вполне приемлемо. Но уже при k = 2 размер такого множества будет составлять более 115 тысяч вариантов, что соответствует полному перебору небольшого словаря, либо же 1 / 27 в нашем случае, и, следовательно, время работы будет достаточно велико. При этом не нужно забывать еще и о том, что для каждого из таких слов необходимо провести поиск на точное совпадение в словаре. Особенности: Алгоритм может быть легко модифицирован для генерации «ошибочных» вариантов по произвольным правилам, и, к тому же, не требует никакой предварительной обработки словаря, и, соответственно, дополнительной памяти. Возможные улучшения: Можно генерировать не всё множество «ошибочных» слов, а только те из них, которые наиболее вероятно могут встретиться в реальной ситуации, например, слова с учетом распространенных орфографических ошибок или ошибок набора. Метод N-грамм Этот метод был придуман довольно давно, и является наиболее широко используемым, так как его реализация крайне проста, и он обеспечивает достаточно хорошую производительность. Алгоритм основывается на принципе: «Если слово А совпадает со словом Б с учетом нескольких ошибок, то с большой долей вероятности у них будет хотя бы одна общая подстрока длины N». Эти подстроки длины N и называются N-граммами. Во время индексации слово разбивается на такие N-граммы, а затем это слово попадает в списки для каждой из этих N-грамм. Во время поиска запрос также разбивается на N-граммы, и для каждой из них производится последовательный перебор списка слов, содержащих такую подстроку. Наиболее часто используемыми на практике являются триграммы — подстроки длины 3. Выбор большего значения N ведет к ограничению на минимальную длину слова, при которой уже возможно обнаружение ошибок. Особенности: Алгоритм N-грамм находит не все возможные слова с ошибками. Если взять, например, слово ВОТКА, и разложить его на триграммы: ВО Т КА → ВО Т О Т К Т КА — то можно заметить, что они все содержат ошибку Т. Таким образом, слово «ВОДКА» найдено не будет, так как оно не содержит ни одной из этих триграмм, и не попадет в соответствующие им списки. Таким образом, чем меньше длина слова и чем больше в нем ошибок, тем выше шанс того, что оно не попадет в соответствующие N-граммам запроса списки, и не будет присутствовать в результате. Между тем, метод N-грамм оставляет полный простор для использования собственных метрик с произвольными свойствами и сложностью, но за это приходится платить — при его использовании остается необходимость в последовательном переборе около 15% словаря, что достаточно много для словарей большого объема. Возможные улучшения: Можно разбивать хеш-таблицы N-грамм по длине слов и по позиции N-граммы в слове (модификация 1). Как длина искомого слова и запроса не могут отличаться более чем на k , так и позиции N-граммы в слове могут различаться не более чем на k. Таким образом, необходимо будет проверить лишь таблицу, соответствующую позиции этой N-граммы в слове, а также k таблиц слева и k таблиц справа, т.е. всего 2k+1 соседних таблиц. Можно еще немного уменьшить размер необходимого для просмотра множества, разбив таблицы по длине слова, и аналогичным образом просматривая только соседние 2k+1 таблицы (модификация 2). Хеширование по сигнатуре Этот алгоритм описан в статье Бойцова Л.М. «Хеширование по сигнатуре». Он базируется на достаточно очевидном представлении «структуры» слова в виде битовых разрядов, используемой в качестве хеша (сигнатуры) в хеш-таблице. При индексации такие хеши вычисляются для каждого из слов, и в таблицу заносится соответствие списка словарных слов этому хешу. Затем, во время поиска, для запроса вычисляется хеш и перебираются все соседние хеши, отличающиеся от исходного не более чем в k битах. Для каждого из таких хешей производится перебор списка соответствующих ему слов. Процесс вычисления хеша — каждому биту хеша сопоставляется группа символов из алфавита. Бит 1 на позиции i в хеше означает, что в исходном слове присутствует символ из i-ой группы алфавита. Порядок букв в слове абсолютно никакого значения не имеет. Удаление одного символа либо не изменит значения хеша (если в слове еще остались символы из той же группы алфавита), либо же соответствующий этой группе бит изменится в 0. При вставке, аналогичным образом либо один бит встанет в 1, либо никаких изменений не будет. При замене символов всё немного сложнее — хеш может либо вовсе остаться неизменным, либо же изменится в 1 или 2 позициях. При перестановках никаких изменений и вовсе не происходит, потому что порядок символов при построении хеша, как и было замечено ранее, не учитывается. Таким образом, для полного покрытия k ошибок нужно изменять не менее 2k бит в хеше. Время работы, в среднем, при k «неполных» (вставки, удаления и транспозиции, а также малая часть замен) ошибках: Особенности: Из того, что при замене одного символа могут изменятся сразу два бита, алгоритм, реализующий, например, искажения не более 2 битов одновременно в действительности не будет выдавать полного объема результатов из-за отсутствия значительной (зависит от отношения размера хеша к алфавиту) части слов с двумя заменами (и чем больше размер хеша, тем чаще замена символа будет приводить к искажению сразу двух бит, и тем менее полным будет результат). К тому же, этот алгоритм не позволяет проводить префиксный поиск. BK-деревья Деревья Burkhard-Keller являются метрическими деревьями, алгоритмы построения таких деревьев основаны на свойстве метрики отвечать неравенству треугольника: Это свойство позволяет метрикам образовывать метрические пространства произвольной размерности. Такие метрические пространства не обязательно являются евклидовыми , так, например, метрики Левенштейна и Дамерау-Левенштейна образуют неевклидовы пространства. На основании этих свойств можно построить структуру данных, осуществляющую поиск в таком метрическом пространстве, которой и являются деревья Баркхарда-Келлера. Улучшения: Можно использовать возможность некоторых метрик вычислять расстояние с ограничением, устанавливая верхний предел, равный сумме максимального расстояния к потомкам вершины и результирующего расстояния, что позволит немного ускорить процесс: Тестирование Тестирование осуществлялось на ноутбуке с Intel Core Duo T2500 (2GHz/667MHz FSB/2MB), 2Gb ОЗУ, ОС — Ubuntu 10.10 Desktop i686, JRE — OpenJDK 6 Update 20. Тестирование осуществлялось с использованием расстояния Дамерау-Левенштейна и количеством ошибок k = 2 . Размер индекса указан вместе со словарем (65 Мб). Расширение выборки Размер индекса: 65 Мб Время поиска: 320 мс / 330 мс Полнота результатов: 100% N-грамм (оригинальный) Размер индекса: 170 Мб Время создания индекса: 32 с Время поиска: 71 мс / 110 мс Полнота результатов: 65% N-грамм (модификация 1) Размер индекса: 170 Мб Время создания индекса: 32 с Время поиска: 39 мс / 46 мс Полнота результатов: 63% N-грамм (модификация 2) Размер индекса: 170 Мб Время создания индекса: 32 с Время поиска: 37 мс / 45 мс Полнота результатов: 62% Хеширование по сигнатуре Размер индекса: 85 Мб Время создания индекса: 0.6 с Время поиска: 55 мс Полнота результатов: 56.5% BK-деревья Размер индекса: 150 Мб Время создания индекса: 120 с Время поиска: 540 мс Полнота результатов: 63% Итого Большинство алгоритмов нечеткого поиска с индексацией не являются истинно сублинейными (т.е. имеющими асимптотическое время работы O(log n) или ниже), и их скорость работы обычно напрямую зависит от N . Тем не менее, множественные улучшения и доработки позволяют добиться достаточного малого времени работы даже при весьма больших объемах словарей. Существует также еще множество разнообразных и неэффективных методов, основанных, помимо всего прочего, на адаптации различных, уже где-либо применяемых техник и приемов к данной предметной области. В числе таких методов — адаптация префиксных деревьев (Trie) к задачам нечеткого поиска , которую я оставил без внимания в виду её малой эффективности. Но есть и алгоритмы, основанные на оригинальных подходах, например, алгоритм Маасса-Новака , который хоть и имеет сублинейное асимптотическое время работы, но является крайне неэффективным из-за огромных констант, скрывающихся за такой временной оценкой, которые проявляются в виде огромного размера индекса. Практическое использование алгоритмов нечеткого поиска в реальных поисковых системах тесно связано с фонетическими алгоритмами , алгоритмами лексического стемминга — выделения базовой части у различных словоформ одного и того же слова (например, такую функциональность предоставляют Snowball и Яндекс mystem ), а также с ранжированием на основе статистической информации, либо же с использованием сложных изощренных метрик. По ссылке http://code.google.com/p/fuzzy-search-tools можно найти мои реализации на Java: Расстояние Левенштейна (с отсечением и префиксным вариантом); Расстояние Дамерау-Левенштейна (с отсечением и префиксным вариантом); Алгоритм Bitap (Shift-OR / Shift-AND с модификациями Wu-Manber); Алгоритм расширения выборки; Метод N-грамм (оригинальный и с модификациями); Метод хеширования по сигнатуре; BK-деревья. Я хотел сделать код удобным для понимания, и вместе с тем достаточно эффективным для практического применения. Выжимать же последние соки из JVM в мои задачи не входило. Enjoy. Стоит заметить, что в процессе изучения этой темы у меня появились кое-какие собственные наработки, позволяющие на порядок сократить время поиска за счет умеренного увеличения размера индекса и некоторого ограничения в свободе выбора метрик. Но это уже совсем другая история. Ссылки: Исходные коды к статье на Java. http://code.google.com/p/fuzzy-search-tools Расстояние Левенштейна. http://ru.wikipedia.org/wiki/Расстояние_Левенштейна Расстояние Дамерау-Левенштейна. http://en.wikipedia.org/wiki/Damerau–Levenshtein_distance Хорошее описание Shift-Or c модификациями Wu-Manber, правда, на немецком. http://de.wikipedia.org/wiki/Baeza-Yates-Gonnet-Algorithmus Метод N-грамм. http://www.cs.helsinki.fi/u/ukkonen/TCS92.pdf Хеширование по сигнатуре. http://itman.narod.ru/articles/rtf/confart.zip Сайт Леонида Моисеевича Бойцова, целиком посвященный нечеткому поиску. http://itman.narod.ru/ Реализация Shift-Or и некоторых других алгоритмов. http://johannburkard.de/software/stringsearch/ Fast Text Searching with Agrep (Wu &amp; Manber). http://www.at.php.net/utils/admin-tools/agrep/agrep.ps.1 Damn Cool Algorithms — автомат Левенштейна, BK-деревья, и еще кое-какие алгоритмы. http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees BK-деревья на Java. http://code.google.com/p/java-bk-tree/ Алгоритм Маасса-Новака. http://yury.name/internet/09ia-seminar.ppt Библиотека метрик SimMetrics. http://staffwww.dcs.shef.ac.uk/people/S.Chapman/simmetrics.html Библиотека метрик SecondString. http://sourceforge.net/projects/secondstring/ English version: Fuzzy string search Tags: алгоритмы поиска нечеткий поиск поиск по сходству левенштейн дамерау-левенштейн bitap wu-manber расширение выборки n-граммы хеширование по сигнатуре bk-деревья fuzzy search similarity search levenstein damerau-levenstein ngram bktree Hubs: Algorithms Total votes 171: ↑170 and ↓1 +169 Add to bookmarks 1050 Comments 33 132 Karma 0 Rating Никита Сметанин @ntz User Follow Send message Comments Comments 33 Articles Top of the day Similar articles Show the best of all time Your account Log in Sign up Sections Articles News Hubs Authors Sandbox Information How it works For authors For companies Documents Agreement Confidential Services Corporate blogs Advertising Native advertising Education programs Startups Facebook Twitter Telegram Language settings Support © 2006–2025, Habr window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"114997":{"id":"114997","timePublished":"2011-03-09T15:47:26+00:00","isCorporative":false,"lang":"ru","titleHtml":"Нечёткий поиск в тексте и словаре","leadData":{"textHtml":"\u003Ch4\u003EВведение\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nАлгоритмы нечеткого поиска (также известного как \u003Ci\u003Eпоиск по сходству\u003C\u002Fi\u003E или \u003Ci\u003Efuzzy string search\u003C\u002Fi\u003E) являются основой систем проверки орфографии и полноценных поисковых систем вроде Google или Yandex. Например, такие алгоритмы используются для функций наподобие «Возможно вы имели в виду …» в тех же поисковых системах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ этой обзорной статье я рассмотрю следующие понятия, методы и алгоритмы:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EРасстояние Левенштейна\u003C\u002Fli\u003E\r\n\u003Cli\u003EРасстояние Дамерау-Левенштейна\u003C\u002Fli\u003E\r\n\u003Cli\u003EАлгоритм Bitap с модификациями от Wu и Manber\u003C\u002Fli\u003E\r\n\u003Cli\u003EАлгоритм расширения выборки\u003C\u002Fli\u003E\r\n\u003Cli\u003EМетод N-грамм\u003C\u002Fli\u003E\r\n\u003Cli\u003EХеширование по сигнатуре\u003C\u002Fli\u003E\r\n\u003Cli\u003EBK-деревья\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003EА также проведу сравнительное тестирование качества и производительности алгоритмов.\u003Cbr\u002F\u003E\r\n","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"61720","alias":"ntz","fullname":"Никита Сметанин","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fa88\u002Fbf6\u002F182\u002Fa88bf6182f3e2255cf8a03734362207a.jpg","speciality":null,"scoreStats":{"score":132,"votesCount":138},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"donationsMethod":null,"isInBlacklist":null,"careerProfile":null},"statistics":{"commentsCount":33,"favoritesCount":1050,"readingCount":268499,"score":169,"votesCount":171,"votesCountPlus":170,"votesCountMinus":1},"hubs":[{"id":"8000","alias":"algorithms","type":"collective","title":"Algorithms","titleHtml":"Algorithms","isProfiled":true,"relatedData":null}],"flows":[{"id":"1","alias":"develop","title":"Development","titleHtml":"Development"}],"relatedData":{"vote":null,"unreadCommentsCount":0,"bookmarked":false,"canComment":false,"canEdit":false,"canViewVotes":false,"votePlus":{"canVote":false,"isChargeEnough":false,"isKarmaEnough":false,"isVotingOver":true,"isPublicationLimitEnough":false},"voteMinus":{"canVote":false,"isChargeEnough":false,"isKarmaEnough":false,"isVotingOver":true,"isPublicationLimitEnough":false},"canModerateComments":false,"trackerSubscribed":false,"emailSubscribed":false},"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Ch4\u003EВведение\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nАлгоритмы нечеткого поиска (также известного как \u003Ci\u003Eпоиск по сходству\u003C\u002Fi\u003E или \u003Ci\u003Efuzzy string search\u003C\u002Fi\u003E) являются основой систем проверки орфографии и полноценных поисковых систем вроде Google или Yandex. Например, такие алгоритмы используются для функций наподобие «Возможно вы имели в виду …» в тех же поисковых системах.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nВ этой обзорной статье я рассмотрю следующие понятия, методы и алгоритмы:\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003EРасстояние Левенштейна\u003C\u002Fli\u003E\n\u003Cli\u003EРасстояние Дамерау-Левенштейна\u003C\u002Fli\u003E\n\u003Cli\u003EАлгоритм Bitap с модификациями от Wu и Manber\u003C\u002Fli\u003E\n\u003Cli\u003EАлгоритм расширения выборки\u003C\u002Fli\u003E\n\u003Cli\u003EМетод N-грамм\u003C\u002Fli\u003E\n\u003Cli\u003EХеширование по сигнатуре\u003C\u002Fli\u003E\n\u003Cli\u003EBK-деревья\u003C\u002Fli\u003E\n\u003C\u002Ful\u003EА также проведу сравнительное тестирование качества и производительности алгоритмов.\u003Cbr\u002F\u003E\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\n\u003Ch4\u003EИтак...\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nНечеткий поиск является крайне полезной функцией любой поисковой системы. Вместе с тем, его эффективная реализация намного сложнее, чем реализация простого поиска по точному совпадению.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nЗадачу нечеткого поиска можно сформулировать так:\u003Cbr\u002F\u003E\n«По заданному слову найти в тексте или словаре размера \u003Cb\u003En\u003C\u002Fb\u003E все слова, совпадающие с этим словом (или начинающиеся с этого слова) с учетом \u003Cb\u003Ek\u003C\u002Fb\u003E возможных различий».\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nНапример, при запросе «Машина» с учетом двух возможных ошибок, найти слова «Машинка», «Махина», «Малина», «Калина» и так далее.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nАлгоритмы нечеткого поиска характеризуются \u003Ci\u003Eметрикой\u003C\u002Fi\u003E — функцией расстояния между двумя словами, позволяющей оценить степень их сходства в данном контексте. Строгое математическое определение \u003Ci\u003Eметрики\u003C\u002Fi\u003E включает в себя необходимость соответствия условию неравенства треугольника (X — множество слов, p — метрика):\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Ff3\u002Fe4\u002Ff3e40b4ae60965d3ec0ee17e21a1435a.png\" alt=\"Неравенство треугольника\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Ff3\u002Fe4\u002Ff3e40b4ae60965d3ec0ee17e21a1435a.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nМежду тем, в большинстве случаев под метрикой подразумевается более общее понятие, не требующее выполнения такого условия, это понятие можно также назвать \u003Ci\u003Eрасстоянием\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nВ числе наиболее известных метрик — расстояния \u003Ci\u003EХемминга\u003C\u002Fi\u003E, \u003Ci\u003EЛевенштейна\u003C\u002Fi\u003E и \u003Ci\u003EДамерау-Левенштейна\u003C\u002Fi\u003E. При этом расстояние Хемминга является метрикой только на множестве слов одинаковой длины, что сильно ограничивает область его применения.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nВпрочем, на практике расстояние Хемминга оказывается практически бесполезным, уступая более естественным с точки зрения человека метрикам, о которых и пойдет речь ниже.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EРасстояние Левенштейна\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nНаиболее часто применяемой метрикой является расстояние Левенштейна, или расстояние редактирования, алгоритмы вычисления которого можно найти на каждом шагу.\u003Cbr\u002F\u003E\nТем не менее, стоит сделать несколько замечаний относительно наиболее популярного алгоритма расчета — \u003Ca href=\"http:\u002F\u002Falgolist.manual.ru\u002Fsearch\u002Flcs\u002Fvagner.php\"\u003Eметода Вагнера-Фишера\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\nИсходный вариант этого алгоритма имеет временную сложность \u003Cb\u003EO(mn)\u003C\u002Fb\u003E и потребляет \u003Cb\u003EO(mn)\u003C\u002Fb\u003E памяти, где \u003Cb\u003Em\u003C\u002Fb\u003E и \u003Cb\u003En\u003C\u002Fb\u003E — длины сравниваемых строк. Весь процесс можно представить следующей матрицей:\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F00\u002F50\u002F0050eb93113049be1fa37d1656bb921a.png\" alt=\"Матрица расстояний Левенштейна\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F00\u002F50\u002F0050eb93113049be1fa37d1656bb921a.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nЕсли посмотреть на процесс работы алгоритма, несложно заметить, что на каждом шаге используются только две последние строки матрицы, следовательно, потребление памяти можно уменьшить до \u003Cb\u003EO(min(m, n))\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F93\u002Fe6\u002F93e6af9530371facbf3f63bd6a33016d.png\" alt=\"Процесс работы алгоритма Левенштейна\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F93\u002Fe6\u002F93e6af9530371facbf3f63bd6a33016d.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nНо это еще не всё — можно дальше оптимизировать алгоритм, если стоит задача нахождения не более k различий. В этом случае нужно вычислять в матрице лишь диагональную полосу шириной \u003Cb\u003E2k+1\u003C\u002Fb\u003E (отсечение Укконена), что сводит временную сложность к \u003Cb\u003EO(k min(m, n))\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch5\u003EПрефиксное расстояние\u003C\u002Fh5\u003E\u003Cbr\u002F\u003E\nТакже бывает необходимо вычислять расстояние между префиксом-образцом и строкой — т. е. найти расстояние между заданным префиксом и ближайшим префиксом строки. В этом случае необходимо взять наименьшее из расстояний от префикса-образца до всех префиксов строки. Очевидно, что префиксное расстояние не может считаться метрикой в строгом математическом смысле, что ограничивает его применение.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nЗачастую при нечетком поиске важно не столько само значение расстояния, сколько факт того, превышает оно или нет определенную величину.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EРасстояние Дамерау-Левенштейна\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nЭта вариация вносит в определение расстояния Левенштейна еще одно правило — \u003Ci\u003Eтранспозиция\u003C\u002Fi\u003E (перестановка) двух соседних букв также учитывается как одна операция, наряду со вставками, удалениями и заменами.\u003Cbr\u002F\u003E\nЕще пару лет назад Фредерик Дамерау мог бы гарантировать, что большинство ошибок при наборе текста — как раз и есть транспозиции. Поэтому именно данная метрика дает наилучшие результаты на практике.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F31\u002F61\u002F31610d09a5734180a75b2274c6bc9901.png\" alt=\"Процесс работы алгоритма Дамерау-Левенштейна\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F31\u002F61\u002F31610d09a5734180a75b2274c6bc9901.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nЧтобы вычислять такое расстояние, достаточно немного модифицировать алгоритм нахождения обычного расстояния Левенштейна следующим образом: хранить не две, а три последних строки матрицы, а также добавить соответствующее дополнительное условие — в случае обнаружения транспозиции при расчете расстояния также учитывать и её стоимость.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nКроме рассмотренных выше, существует еще множество других, иногда применяющихся на практике расстояний, таких как \u003Ca href=\"http:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FJaro–Winkler_distance\"\u003Eметрика Джаро-Винклера\u003C\u002Fa\u003E, многие из которых доступны в библиотеках \u003Ca href=\"http:\u002F\u002Fstaffwww.dcs.shef.ac.uk\u002Fpeople\u002FS.Chapman\u002Fsimmetrics.html\"\u003ESimMetrics\u003C\u002Fa\u003E и \u003Ca href=\"http:\u002F\u002Fsourceforge.net\u002Fprojects\u002Fsecondstring\u002F\"\u003ESecondString\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EАлгоритмы нечеткого поиска без индексации (Онлайн)\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nЭти алгоритмы предназначены для поиска по заранее неизвестному тексту, и могут быть использованы, например, в текстовых редакторах, программах для просмотра документов или в веб-браузерах для поиска по странице. Они не требуют предварительной обработки текста и могут работать с непрерывным потоком данных.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EЛинейный поиск\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nПростое последовательное применение заданной метрики (например, метрики Левенштейна) к словам из входного текста. При использовании метрики с ограничением, этот метод позволяет добиться оптимальной скорости работы. Но, при этом, чем больше \u003Cb\u003Ek\u003C\u002Fb\u003E, тем сильнее возрастает время работы. Асимптотическая оценка времени — \u003Cb\u003EO(kn)\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EBitap (также известный как Shift-Or или Baeza-Yates-Gonnet, и его модификация от Wu-Manber)\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nАлгоритм \u003Ci\u003EBitap\u003C\u002Fi\u003E и различные его модификации наиболее часто используются для нечеткого поиска без индексации. Его вариация используется, например, в unix-утилите \u003Ca href=\"http:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FAgrep\"\u003Eagrep\u003C\u002Fa\u003E, выполняющей функции аналогично стандартному \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FGrep\"\u003Egrep\u003C\u002Fa\u003E, но с поддержкой ошибок в поисковом запросе и даже предоставляя ограниченные возможности для применения регулярных выражений.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nВпервые идею этого алгоритма предложили граждане \u003Cb\u003ERicardo Baeza-Yates\u003C\u002Fb\u003E и \u003Cb\u003EGaston Gonnet\u003C\u002Fb\u003E, опубликовав соответствующую статью в 1992 году.\u003Cbr\u002F\u003E\nОригинальная версия алгоритма имеет дело только с заменами символов, и, фактически, вычисляет расстояние \u003Ci\u003EХемминга\u003C\u002Fi\u003E. Но немного позже \u003Cb\u003ESun Wu\u003C\u002Fb\u003E и \u003Cb\u003EUdi Manber\u003C\u002Fb\u003E предложили модификацию этого алгоритма для вычисления расстояния \u003Ci\u003EЛевенштейна\u003C\u002Fi\u003E, т.е. привнесли поддержку вставок и удалений, и разработали на его основе первую версию утилиты agrep.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cb\u003EОперация Bitshift\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n         \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F53\u002Fa6\u002F53a6cb76ace5d9ef13b85fcaf88d7259.png\" alt=\"Операция Bitshift\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F53\u002Fa6\u002F53a6cb76ace5d9ef13b85fcaf88d7259.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cb\u003EВставки\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F19\u002F1e\u002F191e0882697342b80763901cb81d04af.png\" alt=\"Вставки\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F19\u002F1e\u002F191e0882697342b80763901cb81d04af.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cb\u003EУдаления\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F83\u002F51\u002F835183de0bef3933a9ba1d2690087c04.png\" alt=\"Удаления\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F83\u002F51\u002F835183de0bef3933a9ba1d2690087c04.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cb\u003EЗамены\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Fea\u002Ff5\u002Feaf541b9354c2dbfe4c19fe7443322c9.png\" alt=\"Замены\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Fea\u002Ff5\u002Feaf541b9354c2dbfe4c19fe7443322c9.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cb\u003EРезультирующее значение\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F2e\u002Feb\u002F2eeb9d2ca106a9a4303d838a1df23c99.png\" alt=\"Результат\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F2e\u002Feb\u002F2eeb9d2ca106a9a4303d838a1df23c99.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nГде \u003Cb\u003Ek\u003C\u002Fb\u003E — количество ошибок, \u003Cb\u003Ej\u003C\u002Fb\u003E — индекс символа, \u003Cb\u003Es\u003C\u002Fb\u003E\u003Csub\u003Ex\u003C\u002Fsub\u003E — маска символа (в маске единичные биты располагаются на позициях, соответствующих позициям данного символа в запросе).\u003Cbr\u002F\u003E\nСовпадение или несовпадение запросу определяется самым последним битом результирующего вектора R.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nВысокая скорость работы этого алгоритма обеспечивается за счет битового параллелизма вычислений — за одну операцию возможно провести вычисления над 32 и более битами одновременно.\u003Cbr\u002F\u003E\nПри этом тривиальная реализация поддерживает поиск слов длиной не более 32. Это ограничение обуславливается шириной стандартного типа \u003Ci\u003Eint\u003C\u002Fi\u003E (на 32-битных архитектурах). Можно использовать и типы больших размерностей, но это может в некоторой степени замедлить работу алгоритма.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nНе смотря на то, что асимптотическое время работы этого алгоритма \u003Cb\u003EO(kn)\u003C\u002Fb\u003E совпадает с таковым у линейного метода, он значительно быстрее при длинных запросах и количестве ошибок \u003Cb\u003Ek\u003C\u002Fb\u003E более 2.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EТестирование\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nТестирование осуществлялось на тексте 3.2 млн слов, средняя длина слова — 10.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EТочный поиск\u003C\u002Fh6\u003EВремя поиска: 3562 мс\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EПоиск с использованием метрики Левенштейна\u003C\u002Fh6\u003EВремя поиска при \u003Ci\u003Ek=2\u003C\u002Fi\u003E: 5728 мс\u003Cbr\u002F\u003E\nВремя поиска при \u003Ci\u003Ek=5\u003C\u002Fi\u003E: 8385 мс\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EПоиск с использованием алгоритма Bitap с модификациями Wu-Manber\u003C\u002Fh6\u003EВремя поиска при \u003Ci\u003Ek=2\u003C\u002Fi\u003E: 5499 мс\u003Cbr\u002F\u003E\nВремя поиска при \u003Ci\u003Ek=5\u003C\u002Fi\u003E: 5928 мс\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nОчевидно, что простой перебор с использованием метрики, в отличие от алгоритма Bitap, сильно зависит от количества ошибок \u003Cb\u003Ek\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nТем не менее, если речь заходит о поиске в неизменных текстах большого объема, то время поиска можно значительно сократить, произведя предварительную обработку такого текста, также называемую \u003Ci\u003Eиндексацией\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EАлгоритмы нечеткого поиска с индексацией (Оффлайн)\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nОсобенностью всех алгоритмов нечеткого поиска с индексацией является то, что индекс строится по словарю, составленному по исходному тексту или списку записей в какой-либо базе данных.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nЭти алгоритмы используют различные подходы к решению проблемы — одни из них используют сведение к точному поиску, другие используют свойства метрики для построения различных пространственных структур и так далее.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nПрежде всего, на первом шаге по исходному тексту строится словарь, содержащий слова и их позиции в тексте. Также, можно подсчитывать частоты слов и словосочетаний для улучшения качества результатов поиска.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nПредполагается, что индекс, как и словарь, целиком загружен в память.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nТактико-технические характеристики словаря:\u003Cul\u003E\n\u003Cli\u003EИсходный текст — 8.2 гигабайта материалов библиотеки Мошкова (\u003Ca href=\"http:\u002F\u002Flib.ru\u002F\"\u003Elib.ru\u003C\u002Fa\u003E), 680 млн слов;\u003C\u002Fli\u003E\n\u003Cli\u003EРазмер словаря — 65 мегабайт;\u003C\u002Fli\u003E\n\u003Cli\u003EКоличество слов — 3.2 млн;\u003C\u002Fli\u003E\n\u003Cli\u003EСредняя длина слова — 9.5 символов;\u003C\u002Fli\u003E\n\u003Cli\u003EСредняя квадратичная длина слова (может быть полезна при оценке некоторых алгоритмов) — 10.0 символов;\u003C\u002Fli\u003E\n\u003Cli\u003EАлфавит — заглавные буквы А-Я, без Ё (для упрощения некоторых операций). Слова, содержащие символы не из алфавита, не включены в словарь.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003EЗависимость размера словаря от объема текста не является строго линейной — до некоторого объема формируется базовый каркас слов, составляющий от 15% на 500 тысячах слов до 5% на 5 миллионах, и затем зависимость приближается к линейной, медленно убывая и доходя до 0.5% на 680 млн слов. Последующее сохранение роста обеспечивается в большинстве своем за счет редких слов.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F47\u002F26\u002F4726c1e62497ddcee6dcb649c9b84448.png\" alt=\"Рост размера словаря\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F47\u002F26\u002F4726c1e62497ddcee6dcb649c9b84448.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EАлгоритм расширения выборки\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nЭтот алгоритм часто применяется в системах проверки орфографии (т.е. в spell-checker'ах), там, где размер словаря невелик, либо же где скорость работы не является основным критерием.\u003Cbr\u002F\u003E\nОн основан на сведении задачи о нечетком поиске к задаче о точном поиске.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nИз исходного запроса строится множество «ошибочных» слов, для каждого из которых затем производится точный поиск в словаре.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Fba\u002F45\u002Fba45205a3a3d2b6d18e36dad0116ee14.png\" alt=\"Расширение выборки\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Fba\u002F45\u002Fba45205a3a3d2b6d18e36dad0116ee14.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nВремя его работы сильно зависит от числа k ошибок и от размера алфавита A, и в случае использования бинарного поиска по словарю составляет: \u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Fc8\u002F93\u002Fc8931f2456845c659ea5b4b57e407809.png\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Fc8\u002F93\u002Fc8931f2456845c659ea5b4b57e407809.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nНапример, при \u003Ci\u003Ek = 1\u003C\u002Fi\u003E и слова длины 7 (например, «Крокодил») в русском алфавите множество ошибочных слов будет размером около 450, то есть будет необходимо сделать 450 запросов к словарю, что вполне приемлемо.\u003Cbr\u002F\u003E\nНо уже при \u003Ci\u003Ek = 2\u003C\u002Fi\u003E размер такого множества будет составлять более 115 тысяч вариантов, что соответствует полному перебору небольшого словаря, либо же 1 \u002F 27 в нашем случае, и, следовательно, время работы будет достаточно велико. При этом не нужно забывать еще и о том, что для каждого из таких слов необходимо провести поиск на точное совпадение в словаре.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EОсобенности:\u003C\u002Fh6\u003EАлгоритм может быть легко модифицирован для генерации «ошибочных» вариантов по произвольным правилам, и, к тому же, не требует никакой предварительной обработки словаря, и, соответственно, дополнительной памяти.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EВозможные улучшения:\u003C\u002Fh6\u003EМожно генерировать не всё множество «ошибочных» слов, а только те из них, которые наиболее вероятно могут встретиться в реальной ситуации, например, слова с учетом распространенных орфографических ошибок или ошибок набора.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EМетод N-грамм\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nЭтот метод был придуман довольно давно, и является наиболее широко используемым, так как его реализация крайне проста, и он обеспечивает достаточно хорошую производительность. Алгоритм основывается на принципе:\u003Cbr\u002F\u003E\n«Если слово А совпадает со словом Б с учетом нескольких ошибок, то с большой долей вероятности у них будет хотя бы одна общая подстрока длины N».\u003Cbr\u002F\u003E\nЭти подстроки длины N и называются N-граммами.\u003Cbr\u002F\u003E\nВо время индексации слово разбивается на такие N-граммы, а затем это слово попадает в списки для каждой из этих N-грамм. Во время поиска запрос также разбивается на N-граммы, и для каждой из них производится последовательный перебор списка слов, содержащих такую подстроку.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F57\u002F98\u002F579859076e907968952471e047fd8827.png\" alt=\"Метод N-грамм\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F57\u002F98\u002F579859076e907968952471e047fd8827.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nНаиболее часто используемыми на практике являются триграммы — подстроки длины 3. Выбор большего значения N ведет к ограничению на минимальную длину слова, при которой уже возможно обнаружение ошибок.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EОсобенности:\u003C\u002Fh6\u003EАлгоритм N-грамм находит не все возможные слова с ошибками. Если взять, например, слово ВОТКА, и разложить его на триграммы: ВО\u003Cb\u003EТ\u003C\u002Fb\u003EКА → ВО\u003Cb\u003EТ\u003C\u002Fb\u003E О\u003Cb\u003EТ\u003C\u002Fb\u003EК \u003Cb\u003EТ\u003C\u002Fb\u003EКА — то можно заметить, что они все содержат ошибку Т. Таким образом, слово «ВОДКА» найдено не будет, так как оно не содержит ни одной из этих триграмм, и не попадет в соответствующие им списки. Таким образом, чем меньше длина слова и чем больше в нем ошибок, тем выше шанс того, что оно не попадет в соответствующие N-граммам запроса списки, и не будет присутствовать в результате.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nМежду тем, метод N-грамм оставляет полный простор для использования собственных метрик с произвольными свойствами и сложностью, но за это приходится платить — при его использовании остается необходимость в последовательном переборе около 15% словаря, что достаточно много для словарей большого объема.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EВозможные улучшения:\u003C\u002Fh6\u003EМожно разбивать хеш-таблицы N-грамм по длине слов и по позиции N-граммы в слове (модификация 1). Как длина искомого слова и запроса не могут отличаться более чем на \u003Cb\u003Ek\u003C\u002Fb\u003E, так и позиции N-граммы в слове могут различаться не более чем на k. Таким образом, необходимо будет проверить лишь таблицу, соответствующую позиции этой N-граммы в слове, а также k таблиц слева и k таблиц справа, т.е. всего \u003Cb\u003E2k+1\u003C\u002Fb\u003E соседних таблиц.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F31\u002Faa\u002F31aabd5501fe3712b37aa5c5d388f738.png\" alt=\"Модификация 1 метода N-грамм\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F31\u002Faa\u002F31aabd5501fe3712b37aa5c5d388f738.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nМожно еще немного уменьшить размер необходимого для просмотра множества, разбив таблицы по длине слова, и аналогичным образом просматривая только соседние \u003Cb\u003E2k+1\u003C\u002Fb\u003E таблицы (модификация 2).\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EХеширование по сигнатуре\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nЭтот алгоритм описан в статье Бойцова Л.М. «Хеширование по сигнатуре». Он базируется на достаточно очевидном представлении «структуры» слова в виде битовых разрядов, используемой в качестве хеша (сигнатуры) в хеш-таблице.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nПри индексации такие хеши вычисляются для каждого из слов, и в таблицу заносится соответствие списка словарных слов этому хешу. Затем, во время поиска, для запроса вычисляется хеш и перебираются все соседние хеши, отличающиеся от исходного не более чем в k битах. Для каждого из таких хешей производится перебор списка соответствующих ему слов.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nПроцесс вычисления хеша — каждому биту хеша сопоставляется группа символов из алфавита. Бит 1 на позиции \u003Ci\u003Ei\u003C\u002Fi\u003E в хеше означает, что в исходном слове присутствует символ из \u003Ci\u003Ei-ой\u003C\u002Fi\u003E группы алфавита. Порядок букв в слове абсолютно никакого значения не имеет.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Fb6\u002F19\u002Fb619ac1d4f823ab6f05ef845282b4f44.png\" alt=\"Хеширование по сигнатуре\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Fb6\u002F19\u002Fb619ac1d4f823ab6f05ef845282b4f44.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nУдаление одного символа либо не изменит значения хеша (если в слове еще остались символы из той же группы алфавита), либо же соответствующий этой группе бит изменится в 0. При вставке, аналогичным образом либо один бит встанет в 1, либо никаких изменений не будет. При замене символов всё немного сложнее — хеш может либо вовсе остаться неизменным, либо же изменится в 1 или 2 позициях. При перестановках никаких изменений и вовсе не происходит, потому что порядок символов при построении хеша, как и было замечено ранее, не учитывается. Таким образом, для полного покрытия k ошибок нужно изменять не менее \u003Cb\u003E2k\u003C\u002Fb\u003E бит в хеше.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F42\u002F9a\u002F429a79a33e8a322f317e7a9522877b9e.png\" alt=\"Список хешей с ошибками\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F42\u002F9a\u002F429a79a33e8a322f317e7a9522877b9e.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nВремя работы, в среднем, при k «неполных» (вставки, удаления и транспозиции, а также малая часть замен) ошибках: \u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Fb6\u002Fa0\u002Fb6a09b40a753e6cfa3638c3b3ac6dce4.png\" alt=\"Асимптотическое время работы хеширования по сигнатуре\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Fb6\u002Fa0\u002Fb6a09b40a753e6cfa3638c3b3ac6dce4.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EОсобенности:\u003C\u002Fh6\u003EИз того, что при замене одного символа могут изменятся сразу два бита, алгоритм, реализующий, например, искажения не более 2 битов одновременно в действительности не будет выдавать полного объема результатов из-за отсутствия значительной (зависит от отношения размера хеша к алфавиту) части слов с двумя заменами (и чем больше размер хеша, тем чаще замена символа будет приводить к искажению сразу двух бит, и тем менее полным будет результат). К тому же, этот алгоритм не позволяет проводить префиксный поиск.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EBK-деревья\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nДеревья \u003Ci\u003EBurkhard-Keller\u003C\u002Fi\u003E являются метрическими деревьями, алгоритмы построения таких деревьев основаны на свойстве метрики отвечать неравенству треугольника:\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Ff3\u002Fe4\u002Ff3e40b4ae60965d3ec0ee17e21a1435a.png\" alt=\"Неравенство треугольника\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Ff3\u002Fe4\u002Ff3e40b4ae60965d3ec0ee17e21a1435a.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nЭто свойство позволяет метрикам образовывать метрические пространства произвольной размерности. Такие метрические пространства не обязательно являются \u003Ci\u003Eевклидовыми\u003C\u002Fi\u003E, так, например, метрики \u003Ci\u003EЛевенштейна\u003C\u002Fi\u003E и \u003Ci\u003EДамерау-Левенштейна\u003C\u002Fi\u003E образуют \u003Ci\u003Eнеевклидовы\u003C\u002Fi\u003E пространства. На основании этих свойств можно построить структуру данных, осуществляющую поиск в таком метрическом пространстве, которой и являются деревья Баркхарда-Келлера.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Fc4\u002Ffa\u002Fc4fa48469d65ab0af2e6212ec0970c91.png\" alt=\"BK-дерево\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Fc4\u002Ffa\u002Fc4fa48469d65ab0af2e6212ec0970c91.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EУлучшения:\u003C\u002Fh6\u003EМожно использовать возможность некоторых метрик вычислять расстояние с ограничением, устанавливая верхний предел, равный сумме максимального расстояния к потомкам вершины и результирующего расстояния, что позволит немного ускорить процесс:\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002F26\u002F3f\u002F263fec663f341a02274764d381aae1e3.png\" alt=\"Ограничение метрики в алгоритме BK-деревьев\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002F26\u002F3f\u002F263fec663f341a02274764d381aae1e3.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EТестирование\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nТестирование осуществлялось на ноутбуке с Intel Core Duo T2500 (2GHz\u002F667MHz FSB\u002F2MB), 2Gb ОЗУ, ОС — Ubuntu 10.10 Desktop i686, JRE — OpenJDK 6 Update 20.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage\u002Fhabraeffect\u002Fe4\u002F59\u002Fe4598435e0286cccc8decffbace314b0.png\" alt=\"Сравнение времени работы\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage\u002Fhabraeffect\u002Fe4\u002F59\u002Fe4598435e0286cccc8decffbace314b0.png\"\u002F\u003E\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nТестирование осуществлялось с использованием расстояния Дамерау-Левенштейна и количеством ошибок \u003Ci\u003Ek = 2\u003C\u002Fi\u003E. Размер индекса указан вместе со словарем (65 Мб).\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EРасширение выборки\u003C\u002Fh6\u003EРазмер индекса: 65 Мб\u003Cbr\u002F\u003E\nВремя поиска: 320 мс \u002F 330 мс\u003Cbr\u002F\u003E\nПолнота результатов: 100%\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EN-грамм (оригинальный)\u003C\u002Fh6\u003EРазмер индекса: 170 Мб\u003Cbr\u002F\u003E\nВремя создания индекса: 32 с\u003Cbr\u002F\u003E\nВремя поиска: 71 мс \u002F 110 мс\u003Cbr\u002F\u003E\nПолнота результатов: 65%\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EN-грамм (модификация 1)\u003C\u002Fh6\u003EРазмер индекса: 170 Мб\u003Cbr\u002F\u003E\nВремя создания индекса: 32 с\u003Cbr\u002F\u003E\nВремя поиска: 39 мс \u002F 46 мс\u003Cbr\u002F\u003E\nПолнота результатов: 63%\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EN-грамм (модификация 2)\u003C\u002Fh6\u003EРазмер индекса: 170 Мб\u003Cbr\u002F\u003E\nВремя создания индекса: 32 с\u003Cbr\u002F\u003E\nВремя поиска: 37 мс \u002F 45 мс\u003Cbr\u002F\u003E\nПолнота результатов: 62%\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EХеширование по сигнатуре\u003C\u002Fh6\u003EРазмер индекса: 85 Мб\u003Cbr\u002F\u003E\nВремя создания индекса: 0.6 с\u003Cbr\u002F\u003E\nВремя поиска: 55 мс\u003Cbr\u002F\u003E\nПолнота результатов: 56.5%\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch6\u003EBK-деревья\u003C\u002Fh6\u003EРазмер индекса: 150 Мб\u003Cbr\u002F\u003E\nВремя создания индекса: 120 с\u003Cbr\u002F\u003E\nВремя поиска: 540 мс\u003Cbr\u002F\u003E\nПолнота результатов: 63%\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EИтого\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\nБольшинство алгоритмов нечеткого поиска с индексацией не являются истинно сублинейными (т.е. имеющими асимптотическое время работы \u003Cb\u003EO(log n)\u003C\u002Fb\u003E или ниже), и их скорость работы обычно напрямую зависит от \u003Cb\u003EN\u003C\u002Fb\u003E. Тем не менее, множественные улучшения и доработки позволяют добиться достаточного малого времени работы даже при весьма больших объемах словарей.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nСуществует также еще множество разнообразных и неэффективных методов, основанных, помимо всего прочего, на адаптации различных, уже где-либо применяемых техник и приемов к данной предметной области. В числе таких методов — \u003Ca href=\"http:\u002F\u002Fwww.cs.mcgill.ca\u002F~tim\u002Ftries\u002Ftries.html\"\u003Eадаптация префиксных деревьев (Trie) к задачам нечеткого поиска\u003C\u002Fa\u003E, которую я оставил без внимания в виду её малой эффективности. Но есть и алгоритмы, основанные на оригинальных подходах, например, \u003Ca href=\"http:\u002F\u002Fyury.name\u002Finternet\u002F09ia-seminar.ppt\"\u003Eалгоритм \u003Ci\u003EМаасса-Новака\u003C\u002Fi\u003E\u003C\u002Fa\u003E, который хоть и имеет сублинейное асимптотическое время работы, но является крайне неэффективным из-за огромных констант, скрывающихся за такой временной оценкой, которые проявляются в виде огромного размера индекса.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nПрактическое использование алгоритмов нечеткого поиска в реальных поисковых системах тесно связано с \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fblogs\u002Falgorithm\u002F114947\u002F\"\u003Eфонетическими алгоритмами\u003C\u002Fa\u003E, алгоритмами лексического стемминга — выделения базовой части у различных словоформ одного и того же слова (например, такую функциональность предоставляют \u003Ca href=\"http:\u002F\u002Fsnowball.tartarus.org\u002F\"\u003ESnowball\u003C\u002Fa\u003E и \u003Ca href=\"http:\u002F\u002Fcompany.yandex.ru\u002Ftechnology\u002Fmystem\u002F\"\u003EЯндекс mystem\u003C\u002Fa\u003E), а также с ранжированием на основе статистической информации, либо же с использованием сложных изощренных метрик.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nПо ссылке \u003Ca href=\"http:\u002F\u002Fcode.google.com\u002Fp\u002Ffuzzy-search-tools\"\u003Ehttp:\u002F\u002Fcode.google.com\u002Fp\u002Ffuzzy-search-tools\u003C\u002Fa\u003E можно найти мои реализации на Java:\u003Cul\u003E\n\u003Cli\u003EРасстояние Левенштейна (с отсечением и префиксным вариантом);\u003C\u002Fli\u003E\n\u003Cli\u003EРасстояние Дамерау-Левенштейна (с отсечением и префиксным вариантом);\u003C\u002Fli\u003E\n\u003Cli\u003EАлгоритм Bitap (Shift-OR \u002F Shift-AND с модификациями Wu-Manber);\u003C\u002Fli\u003E\n\u003Cli\u003EАлгоритм расширения выборки;\u003C\u002Fli\u003E\n\u003Cli\u003EМетод N-грамм (оригинальный и с модификациями);\u003C\u002Fli\u003E\n\u003Cli\u003EМетод хеширования по сигнатуре;\u003C\u002Fli\u003E\n\u003Cli\u003EBK-деревья.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003EЯ хотел сделать код удобным для понимания, и вместе с тем достаточно эффективным для практического применения. Выжимать же последние соки из JVM в мои задачи не входило. Enjoy.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\nСтоит заметить, что в процессе изучения этой темы у меня появились кое-какие собственные наработки, позволяющие на порядок сократить время поиска за счет умеренного увеличения размера индекса и некоторого ограничения в свободе выбора метрик. Но это уже совсем другая история.\u003Cbr\u002F\u003E\n\u003Cbr\u002F\u003E\n\u003Ch4\u003EСсылки:\u003C\u002Fh4\u003E\u003Col\u003E\n\u003Cli\u003EИсходные коды к статье на Java. \u003Ca href=\"http:\u002F\u002Fcode.google.com\u002Fp\u002Ffuzzy-search-tools\"\u003Ehttp:\u002F\u002Fcode.google.com\u002Fp\u002Ffuzzy-search-tools\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EРасстояние Левенштейна. \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FРасстояние_Левенштейна\"\u003Ehttp:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FРасстояние_Левенштейна\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EРасстояние Дамерау-Левенштейна. \u003Ca href=\"http:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDamerau–Levenshtein_distance\"\u003Ehttp:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDamerau–Levenshtein_distance\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EХорошее описание Shift-Or c модификациями Wu-Manber, правда, на немецком. \u003Ca href=\"http:\u002F\u002Fde.wikipedia.org\u002Fwiki\u002FBaeza-Yates-Gonnet-Algorithmus\"\u003Ehttp:\u002F\u002Fde.wikipedia.org\u002Fwiki\u002FBaeza-Yates-Gonnet-Algorithmus\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EМетод N-грамм. \u003Ca href=\"http:\u002F\u002Fwww.cs.helsinki.fi\u002Fu\u002Fukkonen\u002FTCS92.pdf\"\u003Ehttp:\u002F\u002Fwww.cs.helsinki.fi\u002Fu\u002Fukkonen\u002FTCS92.pdf\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EХеширование по сигнатуре. \u003Ca href=\"http:\u002F\u002Fitman.narod.ru\u002Farticles\u002Frtf\u002Fconfart.zip\"\u003Ehttp:\u002F\u002Fitman.narod.ru\u002Farticles\u002Frtf\u002Fconfart.zip\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EСайт Леонида Моисеевича Бойцова, целиком посвященный нечеткому поиску. \u003Ca href=\"http:\u002F\u002Fitman.narod.ru\u002F\"\u003Ehttp:\u002F\u002Fitman.narod.ru\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EРеализация Shift-Or и некоторых других алгоритмов. \u003Ca href=\"http:\u002F\u002Fjohannburkard.de\u002Fsoftware\u002Fstringsearch\u002F\"\u003Ehttp:\u002F\u002Fjohannburkard.de\u002Fsoftware\u002Fstringsearch\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EFast Text Searching with Agrep (Wu &amp; Manber). \u003Ca href=\"http:\u002F\u002Fwww.at.php.net\u002Futils\u002Fadmin-tools\u002Fagrep\u002Fagrep.ps.1\"\u003Ehttp:\u002F\u002Fwww.at.php.net\u002Futils\u002Fadmin-tools\u002Fagrep\u002Fagrep.ps.1\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EDamn Cool Algorithms — автомат Левенштейна, BK-деревья, и еще кое-какие алгоритмы. \u003Ca href=\"http:\u002F\u002Fblog.notdot.net\u002F2007\u002F4\u002FDamn-Cool-Algorithms-Part-1-BK-Trees\"\u003Ehttp:\u002F\u002Fblog.notdot.net\u002F2007\u002F4\u002FDamn-Cool-Algorithms-Part-1-BK-Trees\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EBK-деревья на Java. \u003Ca href=\"http:\u002F\u002Fcode.google.com\u002Fp\u002Fjava-bk-tree\u002F\"\u003Ehttp:\u002F\u002Fcode.google.com\u002Fp\u002Fjava-bk-tree\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EАлгоритм Маасса-Новака. \u003Ca href=\"http:\u002F\u002Fyury.name\u002Finternet\u002F09ia-seminar.ppt\"\u003Ehttp:\u002F\u002Fyury.name\u002Finternet\u002F09ia-seminar.ppt\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EБиблиотека метрик SimMetrics. \u003Ca href=\"http:\u002F\u002Fstaffwww.dcs.shef.ac.uk\u002Fpeople\u002FS.Chapman\u002Fsimmetrics.html\"\u003Ehttp:\u002F\u002Fstaffwww.dcs.shef.ac.uk\u002Fpeople\u002FS.Chapman\u002Fsimmetrics.html\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EБиблиотека метрик SecondString. \u003Ca href=\"http:\u002F\u002Fsourceforge.net\u002Fprojects\u002Fsecondstring\u002F\"\u003Ehttp:\u002F\u002Fsourceforge.net\u002Fprojects\u002Fsecondstring\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\nEnglish version: \u003Ca href=\"http:\u002F\u002Fntz-develop.blogspot.com\u002F2011\u002F03\u002Ffuzzy-string-search.html\"\u003EFuzzy string search\u003C\u002Fa\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"алгоритмы поиска"},{"titleHtml":"нечеткий поиск"},{"titleHtml":"поиск по сходству"},{"titleHtml":"левенштейн"},{"titleHtml":"дамерау-левенштейн"},{"titleHtml":"bitap"},{"titleHtml":"wu-manber"},{"titleHtml":"расширение выборки"},{"titleHtml":"n-граммы"},{"titleHtml":"хеширование по сигнатуре"},{"titleHtml":"bk-деревья"},{"titleHtml":"fuzzy search"},{"titleHtml":"similarity search"},{"titleHtml":"levenstein"},{"titleHtml":"damerau-levenstein"},{"titleHtml":"ngram"},{"titleHtml":"bktree"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F114997\u002Fb814e0c13ba6b58420b4af47c19eaa52\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F114997\u002Fb814e0c13ba6b58420b4af47c19eaa52\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Farticles\\\u002F114997\\\u002F\"},\"headline\":\"Нечёткий поиск в тексте и словаре\",\"datePublished\":\"2011-03-09T18:47:26+03:00\",\"dateModified\":\"2011-07-05T21:27:36+04:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Никита Сметанин\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Введение Алгоритмы нечеткого поиска (также известного как поиск по сходству или fuzzy string search) являются основой систем проверки орфографии и полноценных по...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Farticles\\\u002F114997\\\u002F#post-content-body\",\"about\":[\"h_algorithms\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Ff3\\\u002Fe4\\\u002Ff3e40b4ae60965d3ec0ee17e21a1435a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F00\\\u002F50\\\u002F0050eb93113049be1fa37d1656bb921a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F93\\\u002Fe6\\\u002F93e6af9530371facbf3f63bd6a33016d.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F31\\\u002F61\\\u002F31610d09a5734180a75b2274c6bc9901.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F53\\\u002Fa6\\\u002F53a6cb76ace5d9ef13b85fcaf88d7259.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F19\\\u002F1e\\\u002F191e0882697342b80763901cb81d04af.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F83\\\u002F51\\\u002F835183de0bef3933a9ba1d2690087c04.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Fea\\\u002Ff5\\\u002Feaf541b9354c2dbfe4c19fe7443322c9.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F2e\\\u002Feb\\\u002F2eeb9d2ca106a9a4303d838a1df23c99.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F47\\\u002F26\\\u002F4726c1e62497ddcee6dcb649c9b84448.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Fba\\\u002F45\\\u002Fba45205a3a3d2b6d18e36dad0116ee14.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Fc8\\\u002F93\\\u002Fc8931f2456845c659ea5b4b57e407809.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F57\\\u002F98\\\u002F579859076e907968952471e047fd8827.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F31\\\u002Faa\\\u002F31aabd5501fe3712b37aa5c5d388f738.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Fb6\\\u002F19\\\u002Fb619ac1d4f823ab6f05ef845282b4f44.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F42\\\u002F9a\\\u002F429a79a33e8a322f317e7a9522877b9e.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Fb6\\\u002Fa0\\\u002Fb6a09b40a753e6cfa3638c3b3ac6dce4.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Ff3\\\u002Fe4\\\u002Ff3e40b4ae60965d3ec0ee17e21a1435a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Fc4\\\u002Ffa\\\u002Fc4fa48469d65ab0af2e6212ec0970c91.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002F26\\\u002F3f\\\u002F263fec663f341a02274764d381aae1e3.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fstorage\\\u002Fhabraeffect\\\u002Fe4\\\u002F59\\\u002Fe4598435e0286cccc8decffbace314b0.png\"]}","metaDescription":"Введение Алгоритмы нечеткого поиска (также известного как поиск по сходству или fuzzy string search ) являются основой систем проверки орфографии и полноценных поисковых систем вроде Google или...","mainImageUrl":null,"amp":true,"customTrackerLinks":[]},"polls":[],"commentsEnabled":{"status":true,"reason":null},"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"hasPinnedComments":false,"format":null,"banner":null,"multiwidget":null,"multiwidgetUuid":null,"readingTime":13,"complexity":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"postReasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"viewedPosts":[],"myFeedFilter":{"complexity":"all","score":"all","types":["articles","posts","news"]},"myFeedIsApplyFilters":false,"myFeedIsForce":false,"karma":{"userReasonsList":null}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"articlePinnedComments":{},"searchCommentsResults":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":"","idempotenceKey":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"multiwidgets":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"multiwidgetLoading":false,"vacancies":{},"companiesGalleries":{},"companiesBanners":{},"companiesLandingVacancies":{},"companiesTechnologies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null,"jivoStatus":0,"adminNotifications":null,"availableInvitesCount":{}},"companyAdd":{"currentStep":"","stepsData":{},"uncompletedSteps":[],"isStepLoading":true,"isStepCommitting":false,"isInitialized":false,"agreementContent":""},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"pagesCount":0},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":true},"fixedBanner":{"isArticleStickyPanelVisible":false,"isArticleStickyPanelAtTheBottom":false,"isFixedBannerVisible":false,"isStickyPanelIconsHidden":false},"flows":{"flows":[{"id":"1","alias":"develop","title":"Development","titleHtml":"Development","route":{"name":"FLOW_PAGE","params":{"flowName":"develop","hl":"en"}}},{"id":"6","alias":"admin","title":"Administrating","titleHtml":"Administrating","route":{"name":"FLOW_PAGE","params":{"flowName":"admin","hl":"en"}}},{"id":"2","alias":"design","title":"Design","titleHtml":"Design","route":{"name":"FLOW_PAGE","params":{"flowName":"design","hl":"en"}}},{"id":"3","alias":"management","title":"Management","titleHtml":"Management","route":{"name":"FLOW_PAGE","params":{"flowName":"management","hl":"en"}}},{"id":"4","alias":"marketing","title":"Marketing","titleHtml":"Marketing","route":{"name":"FLOW_PAGE","params":{"flowName":"marketing","hl":"en"}}},{"id":"7","alias":"popsci","title":"PopSci","titleHtml":"PopSci","route":{"name":"FLOW_PAGE","params":{"flowName":"popsci","hl":"en"}}}],"updates":{}},"global":{"isPwa":false,"device":"desktop","isHabrCom":true,"requestId":"ebe62b4fcff971d0cb73692a7f17eb06"},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"en","hl":"en"},"info":{"welcomePage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"query":{},"pathname":"\u002Fen\u002Farticles\u002F114997\u002F","path":"\u002Fen\u002Farticles\u002F114997\u002F","href":"\u002Fen\u002Farticles\u002F114997\u002F"}},"me":{"user":null,"uuid":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null,"userUpdates":{"feeds":{"newPostsCount":null,"newThreadsCount":null,"newNewsCount":null,"newCount":null},"conversationUnreadCount":0}},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"onboarding":{"currentStep":null,"stepsData":{},"stepsErrors":{},"completedSteps":[],"isStepCommitting":false,"isCommitDisabled":true},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{"questions":"project-block-article"}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null,"sticker":null},"publicationStatistics":{"statsInfo":{},"statsFunnels":{},"statsGraph":{},"defaultSuggest":{},"suggest":{},"timeTracker":{},"isTrackingActivity":false,"isUserActive":true,"otherPublicationStats":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":true,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"stories":{"stories":[]},"technotext":{"years":[],"technotextDocForNominees":null,"technotextDocForWinners":null,"technotextInfo":{},"technotextInfoLoading":false,"technotextWinners":{},"technotextWinnersLoading":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"userVotes":{"karmaVotesList":[],"karmaVotesPagesCount":null,"karmaVotesListLoading":false,"commentsVotesList":[],"commentsVotesPagesCount":null,"commentsVotesListLoading":false,"postsVotesList":[],"postsVotesPagesCount":null,"postsVotesListLoading":false,"userVotesList":[],"userVotesPagesCount":null,"userVotesListLoading":false},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{"ntz":{"alias":"ntz","badgets":[{"title":"Habred","description":"User with karma \u003E 0.","url":null,"isRemovable":false},{"title":"Oldtimer","description":"User, registered more than 3 years ago, with karma more than 50.","url":null,"isRemovable":false}],"aboutHtml":"","contacts":[{"title":"Website","url":"http:\u002F\u002Fntz-develop.blogspot.com","value":"http:\u002F\u002Fntz-develop.blogspot.com","siteTitle":"Nikita's blog","favicon":"http:\u002F\u002Fntz-develop.blogspot.com\u002Ffavicon.ico"},{"title":"Facebook","url":"https:\u002F\u002Ffacebook.com\u002Fnsmetanin","value":"nsmetanin","siteTitle":"Facebook","favicon":"https:\u002F\u002Fstatic.xx.fbcdn.net\u002Frsrc.php\u002FyB\u002Fr\u002F2sFJRNmJ5OP.ico"},{"title":"Github","url":"https:\u002F\u002Fgithub.com\u002Fnsmetanin\u002F","value":"nsmetanin","siteTitle":"nsmetanin · GitHub","favicon":"https:\u002F\u002Fgithub.githubassets.com\u002Ffavicons\u002Ffavicon.svg"},{"title":"ICQ","url":"https:\u002F\u002Ficq.com\u002F6144443","value":"6144443","siteTitle":null,"favicon":null},{"title":"Twitter","url":"https:\u002F\u002Ftwitter.com\u002Fnsmetanin","value":"nsmetanin","siteTitle":null,"favicon":null}],"invitedBy":{"issuerLogin":null,"timeCreated":"2011-03-04T13:40:26+00:00"},"careerProfile":null,"companies":{"pagesCount":1,"companyIds":[],"companyRefs":{}}}},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"notificationsLoading":false,"notificationsList":[],"notificationsPageCount":0,"pendingMarkNotificationsRead":[],"publicationsLoading":true,"publicationsList":[],"publicationsPageCount":0,"pendingDeletePublications":false,"pendingMarkPublicationsRead":false},"events":{"eventRefs":{},"eventIds":[],"pagesCount":0,"categories":[],"cities":[],"actualEvents":null,"currentEvent":null,"eventsFilter":{"city":"all","timeStarted":null,"timeEnded":null}},"wysiwyg":{"WYSIWYGRulesRefs":null},"hint":{"hints":{}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}()); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); window.addEventListener('load', function () { setTimeout(() => { const img = new Image(); img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE'; }, 0); });